import{K,minValue,tweenTypes,valueTypes,compositionTypes,isDomSymbol,transformsSymbol,emptyString,transformsFragmentStrings,}from'./consts.js';import{mergeObjects,cloneArray,isArr,isObj,isUnd,isKey,addChild,forEachChildren,clampInfinity,normalizeTime,isNum,round,}from'./helpers.js';import{globals,}from'./globals.js';import{registerTargets,}from'./targets.js';import{parseEasings,}from'./eases.js';import{getRelativeValue,getFunctionValue,getOriginalAnimatableValue,getTweenType,setValue,decomposeRawValue,decomposeTweenValue,decomposedOriginalValue,createDecomposedValueTargetObject,}from'./values.js';import{sanitizePropertyName,}from'./properties.js';import{convertValueUnit,}from'./units.js';import{composeTween,getTweenSiblings,overrideTween,}from'./compositions.js';import{additive,}from'./additive.js';import{Timer,}from'./timer.js';export const cleanInlineStyles=renderable=>{if(renderable._hasChildren){forEachChildren(renderable,cleanInlineStyles,true);}else{const animation=(renderable);animation.pause();forEachChildren(animation,(tween)=>{const tweenProperty=tween.property;const tweenTarget=tween.target;if(tweenTarget[isDomSymbol]){const targetStyle=(tweenTarget).style;const originalInlinedValue=animation._inlineStyles[tweenProperty];if(tween._tweenType===tweenTypes.TRANSFORM){const cachedTransforms=tweenTarget[transformsSymbol];if(isUnd(originalInlinedValue)||originalInlinedValue===emptyString){delete cachedTransforms[tweenProperty];}else{cachedTransforms[tweenProperty]=originalInlinedValue;}
if(tween._renderTransforms){if(!Object.keys(cachedTransforms).length){targetStyle.removeProperty('transform');}else{let str=emptyString;for(let key in cachedTransforms){str+=transformsFragmentStrings[key]+cachedTransforms[key]+') ';}
targetStyle.transform=str;}}}else{if(isUnd(originalInlinedValue)||originalInlinedValue===emptyString){targetStyle.removeProperty(tweenProperty);}else{targetStyle[tweenProperty]=originalInlinedValue;}}
if(animation._tail===tween){animation.targets.forEach(t=>{if(t.getAttribute&&t.getAttribute('style')===emptyString){t.removeAttribute('style');};});}}})}
return renderable;}
const fromTargetObject=createDecomposedValueTargetObject();const toTargetObject=createDecomposedValueTargetObject();const toFunctionStore={func:null};const keyframesTargetArray=[null];const fastSetValuesArray=[null,null];const keyObjectTarget={to:null};let tweenId=0;let keyframes;let key;const generateKeyframes=(keyframes,parameters)=>{const properties={};if(isArr(keyframes)){const propertyNames=[].concat(...(keyframes).map(key=>Object.keys(key))).filter(isKey);for(let i=0,l=propertyNames.length;i<l;i++){const propName=propertyNames[i];const propArray=(keyframes).map(key=>{const newKey={};for(let p in key){const keyValue=(key[p]);if(isKey(p)){if(p===propName){newKey.to=keyValue;}}else{newKey[p]=keyValue;}}
return newKey;});properties[propName]=(propArray);}}else{const totalDuration=(setValue(parameters.duration,globals.defaults.duration));const keys=Object.keys(keyframes).map(key=>{return{o:parseFloat(key)/ 100,p:keyframes[key]}}).sort((a,b)=>a.o-b.o);keys.forEach(key=>{const offset=key.o;const prop=key.p;for(let name in prop){if(isKey(name)){let propArray=(properties[name]);if(!propArray)propArray=properties[name]=[];const duration=offset*totalDuration;let length=propArray.length;let prevKey=propArray[length-1];const keyObj={to:prop[name]};let durProgress=0;for(let i=0;i<length;i++){durProgress+=propArray[i].duration;}
if(length===1){keyObj.from=prevKey.to;}
if(prop.ease){keyObj.ease=prop.ease;}
keyObj.duration=duration-(length?durProgress:0);propArray.push(keyObj);}}
return key;});for(let name in properties){const propArray=(properties[name]);let prevEase;for(let i=0,l=propArray.length;i<l;i++){const prop=propArray[i];const currentEase=prop.ease;prop.ease=prevEase?prevEase:undefined;prevEase=currentEase;}
if(!propArray[0].duration){propArray.shift();}}}
return properties;}
export class JSAnimation extends Timer{constructor(targets,parameters,parent,parentPosition,fastSet=false,index=0,length=0){super((parameters),parent,parentPosition);const parsedTargets=registerTargets(targets);const targetsLength=parsedTargets.length;const kfParams=(parameters).keyframes;const params=(kfParams?mergeObjects(generateKeyframes((kfParams),parameters),parameters):parameters);const{delay,duration,ease,playbackEase,modifier,composition,onRender,}=params;const animDefaults=parent?parent.defaults:globals.defaults;const animaPlaybackEase=setValue(playbackEase,animDefaults.playbackEase);const animEase=animaPlaybackEase?parseEasings(animaPlaybackEase):null;const hasSpring=!isUnd(ease)&&!isUnd((ease).ease);const tEasing=hasSpring?(ease).ease:setValue(ease,animEase?'linear':animDefaults.ease);const tDuration=hasSpring?(ease).duration:setValue(duration,animDefaults.duration);const tDelay=setValue(delay,animDefaults.delay);const tModifier=modifier||animDefaults.modifier;const tComposition=isUnd(composition)&&targetsLength>=K?compositionTypes.none:!isUnd(composition)?composition:animDefaults.composition;const animInlineStyles={};const absoluteOffsetTime=this._offset+(parent?parent._offset:0);let iterationDuration=NaN;let iterationDelay=NaN;let animationAnimationLength=0;let shouldTriggerRender=0;for(let targetIndex=0;targetIndex<targetsLength;targetIndex++){const target=parsedTargets[targetIndex];const ti=index||targetIndex;const tl=length||targetsLength;let lastTransformGroupIndex=NaN;let lastTransformGroupLength=NaN;for(let p in params){if(isKey(p)){const tweenType=getTweenType(target,p);const propName=sanitizePropertyName(p,target,tweenType);let propValue=params[p];const isPropValueArray=isArr(propValue);if(fastSet&&!isPropValueArray){fastSetValuesArray[0]=propValue;fastSetValuesArray[1]=propValue;propValue=fastSetValuesArray;}
if(isPropValueArray){const arrayLength=(propValue).length;const isNotObjectValue=!isObj(propValue[0]);if(arrayLength===2&&isNotObjectValue){keyObjectTarget.to=((propValue));keyframesTargetArray[0]=keyObjectTarget;keyframes=keyframesTargetArray;}else if(arrayLength>2&&isNotObjectValue){keyframes=[];(propValue).forEach((v,i)=>{if(!i){fastSetValuesArray[0]=v;}else if(i===1){fastSetValuesArray[1]=v;keyframes.push(fastSetValuesArray);}else{keyframes.push(v);}});}else{keyframes=(propValue);}}else{keyframesTargetArray[0]=propValue;keyframes=keyframesTargetArray;}
let siblings=null;let prevTween=null;let firstTweenChangeStartTime=NaN;let lastTweenChangeEndTime=0;let tweenIndex=0;for(let l=keyframes.length;tweenIndex<l;tweenIndex++){const keyframe=keyframes[tweenIndex];if(isObj(keyframe)){key=keyframe;}else{keyObjectTarget.to=(keyframe);key=keyObjectTarget;}
toFunctionStore.func=null;const computedToValue=getFunctionValue(key.to,target,ti,tl,toFunctionStore);let tweenToValue;if(isObj(computedToValue)&&!isUnd(computedToValue.to)){key=computedToValue;tweenToValue=computedToValue.to;}else{tweenToValue=computedToValue;}
const tweenFromValue=getFunctionValue(key.from,target,ti,tl);const keyEasing=key.ease;const hasSpring=!isUnd(keyEasing)&&!isUnd((keyEasing).ease);const tweenEasing=hasSpring?(keyEasing).ease:keyEasing||tEasing;const tweenDuration=hasSpring?(keyEasing).duration:getFunctionValue(setValue(key.duration,(l>1?getFunctionValue(tDuration,target,ti,tl)/ l:tDuration)),target,ti,tl);const tweenDelay=getFunctionValue(setValue(key.delay,(!tweenIndex?tDelay:0)),target,ti,tl);const computedComposition=getFunctionValue(setValue(key.composition,tComposition),target,ti,tl);const tweenComposition=isNum(computedComposition)?computedComposition:compositionTypes[computedComposition];const tweenModifier=key.modifier||tModifier;const hasFromvalue=!isUnd(tweenFromValue);const hasToValue=!isUnd(tweenToValue);const isFromToArray=isArr(tweenToValue);const isFromToValue=isFromToArray||(hasFromvalue&&hasToValue);const tweenStartTime=prevTween?lastTweenChangeEndTime+tweenDelay:tweenDelay;const absoluteStartTime=absoluteOffsetTime+tweenStartTime;if(!shouldTriggerRender&&(hasFromvalue||isFromToArray))shouldTriggerRender=1;let prevSibling=prevTween;if(tweenComposition!==compositionTypes.none){if(!siblings)siblings=getTweenSiblings(target,propName);let nextSibling=siblings._head;while(nextSibling&&!nextSibling._isOverridden&&nextSibling._absoluteStartTime<=absoluteStartTime){prevSibling=nextSibling;nextSibling=nextSibling._nextRep;if(nextSibling&&nextSibling._absoluteStartTime>=absoluteStartTime){while(nextSibling){overrideTween(nextSibling);nextSibling=nextSibling._nextRep;}}}}
if(isFromToValue){decomposeRawValue(isFromToArray?getFunctionValue(tweenToValue[0],target,ti,tl):tweenFromValue,fromTargetObject);decomposeRawValue(isFromToArray?getFunctionValue(tweenToValue[1],target,ti,tl,toFunctionStore):tweenToValue,toTargetObject);if(fromTargetObject.t===valueTypes.NUMBER){if(prevSibling){if(prevSibling._valueType===valueTypes.UNIT){fromTargetObject.t=valueTypes.UNIT;fromTargetObject.u=prevSibling._unit;}}else{decomposeRawValue(getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),decomposedOriginalValue);if(decomposedOriginalValue.t===valueTypes.UNIT){fromTargetObject.t=valueTypes.UNIT;fromTargetObject.u=decomposedOriginalValue.u;}}}}else{if(hasToValue){decomposeRawValue(tweenToValue,toTargetObject);}else{if(prevTween){decomposeTweenValue(prevTween,toTargetObject);}else{decomposeRawValue(parent&&prevSibling&&prevSibling.parent.parent===parent?prevSibling._value:getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),toTargetObject);}}
if(hasFromvalue){decomposeRawValue(tweenFromValue,fromTargetObject);}else{if(prevTween){decomposeTweenValue(prevTween,fromTargetObject);}else{decomposeRawValue(parent&&prevSibling&&prevSibling.parent.parent===parent?prevSibling._value:getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),fromTargetObject);}}}
if(fromTargetObject.o){fromTargetObject.n=getRelativeValue(!prevSibling?decomposeRawValue(getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),decomposedOriginalValue).n:prevSibling._toNumber,fromTargetObject.n,fromTargetObject.o);}
if(toTargetObject.o){toTargetObject.n=getRelativeValue(fromTargetObject.n,toTargetObject.n,toTargetObject.o);}
if(fromTargetObject.t!==toTargetObject.t){if(fromTargetObject.t===valueTypes.COMPLEX||toTargetObject.t===valueTypes.COMPLEX){const complexValue=fromTargetObject.t===valueTypes.COMPLEX?fromTargetObject:toTargetObject;const notComplexValue=fromTargetObject.t===valueTypes.COMPLEX?toTargetObject:fromTargetObject;notComplexValue.t=valueTypes.COMPLEX;notComplexValue.s=cloneArray(complexValue.s);notComplexValue.d=complexValue.d.map(()=>notComplexValue.n);}else if(fromTargetObject.t===valueTypes.UNIT||toTargetObject.t===valueTypes.UNIT){const unitValue=fromTargetObject.t===valueTypes.UNIT?fromTargetObject:toTargetObject;const notUnitValue=fromTargetObject.t===valueTypes.UNIT?toTargetObject:fromTargetObject;notUnitValue.t=valueTypes.UNIT;notUnitValue.u=unitValue.u;}else if(fromTargetObject.t===valueTypes.COLOR||toTargetObject.t===valueTypes.COLOR){const colorValue=fromTargetObject.t===valueTypes.COLOR?fromTargetObject:toTargetObject;const notColorValue=fromTargetObject.t===valueTypes.COLOR?toTargetObject:fromTargetObject;notColorValue.t=valueTypes.COLOR;notColorValue.s=colorValue.s;notColorValue.d=[0,0,0,1];}}
if(fromTargetObject.u!==toTargetObject.u){let valueToConvert=toTargetObject.u?fromTargetObject:toTargetObject;valueToConvert=convertValueUnit((target),valueToConvert,toTargetObject.u?toTargetObject.u:fromTargetObject.u,false);}
if(toTargetObject.d&&fromTargetObject.d&&(toTargetObject.d.length!==fromTargetObject.d.length)){const longestValue=fromTargetObject.d.length>toTargetObject.d.length?fromTargetObject:toTargetObject;const shortestValue=longestValue===fromTargetObject?toTargetObject:fromTargetObject;shortestValue.d=longestValue.d.map((_,i)=>isUnd(shortestValue.d[i])?0:shortestValue.d[i]);shortestValue.s=cloneArray(longestValue.s);}
const tweenUpdateDuration=round(+tweenDuration||minValue,12);const tween={parent:this,id:tweenId++,property:propName,target:target,_value:null,_func:toFunctionStore.func,_ease:parseEasings(tweenEasing),_fromNumbers:cloneArray(fromTargetObject.d),_toNumbers:cloneArray(toTargetObject.d),_strings:cloneArray(toTargetObject.s),_fromNumber:fromTargetObject.n,_toNumber:toTargetObject.n,_numbers:cloneArray(fromTargetObject.d),_number:fromTargetObject.n,_unit:toTargetObject.u,_modifier:tweenModifier,_currentTime:0,_startTime:tweenStartTime,_delay:+tweenDelay,_updateDuration:tweenUpdateDuration,_changeDuration:tweenUpdateDuration,_absoluteStartTime:absoluteStartTime,_tweenType:tweenType,_valueType:toTargetObject.t,_composition:tweenComposition,_isOverlapped:0,_isOverridden:0,_renderTransforms:0,_prevRep:null,_nextRep:null,_prevAdd:null,_nextAdd:null,_prev:null,_next:null,}
if(tweenComposition!==compositionTypes.none){composeTween(tween,siblings);}
if(isNaN(firstTweenChangeStartTime)){firstTweenChangeStartTime=tween._startTime;}
lastTweenChangeEndTime=round(tweenStartTime+tweenUpdateDuration,12);prevTween=tween;animationAnimationLength++;addChild(this,tween);}
if(isNaN(iterationDelay)||firstTweenChangeStartTime<iterationDelay){iterationDelay=firstTweenChangeStartTime;}
if(isNaN(iterationDuration)||lastTweenChangeEndTime>iterationDuration){iterationDuration=lastTweenChangeEndTime;}
if(tweenType===tweenTypes.TRANSFORM){lastTransformGroupIndex=animationAnimationLength-tweenIndex;lastTransformGroupLength=animationAnimationLength;}}}
if(!isNaN(lastTransformGroupIndex)){let i=0;forEachChildren(this,(tween)=>{if(i>=lastTransformGroupIndex&&i<lastTransformGroupLength){tween._renderTransforms=1;if(tween._composition===compositionTypes.blend){forEachChildren(additive.animation,(additiveTween)=>{if(additiveTween.id===tween.id){additiveTween._renderTransforms=1;}});}}
i++;});}}
if(!targetsLength){console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);}
if(iterationDelay){forEachChildren(this,(tween)=>{if(!(tween._startTime-tween._delay)){tween._delay-=iterationDelay;}
tween._startTime-=iterationDelay;});iterationDuration-=iterationDelay;}else{iterationDelay=0;}
if(!iterationDuration){iterationDuration=minValue;this.iterationCount=0;}
this.targets=parsedTargets;this.duration=iterationDuration===minValue?minValue:clampInfinity(((iterationDuration+this._loopDelay)*this.iterationCount)-this._loopDelay)||minValue;this.onRender=onRender||animDefaults.onRender;this._ease=animEase;this._delay=iterationDelay;this.iterationDuration=iterationDuration;this._inlineStyles=animInlineStyles;if(!this._autoplay&&shouldTriggerRender)this.onRender(this);}
stretch(newDuration){const currentDuration=this.duration;if(currentDuration===normalizeTime(newDuration))return this;const timeScale=newDuration / currentDuration;forEachChildren(this,(tween)=>{tween._updateDuration=normalizeTime(tween._updateDuration*timeScale);tween._changeDuration=normalizeTime(tween._changeDuration*timeScale);tween._currentTime*=timeScale;tween._startTime*=timeScale;tween._absoluteStartTime*=timeScale;});return super.stretch(newDuration);}
refresh(){forEachChildren(this,(tween)=>{const ogValue=getOriginalAnimatableValue(tween.target,tween.property,tween._tweenType);decomposeRawValue(ogValue,decomposedOriginalValue);tween._fromNumbers=cloneArray(decomposedOriginalValue.d);tween._fromNumber=decomposedOriginalValue.n;if(tween._func){decomposeRawValue(tween._func(),toTargetObject);tween._toNumbers=cloneArray(toTargetObject.d);tween._strings=cloneArray(toTargetObject.s);tween._toNumber=toTargetObject.n;}});return this;}
revert(){super.revert();return cleanInlineStyles(this);}
then(callback){return super.then(callback);}}
export const animate=(targets,parameters)=>new JSAnimation(targets,parameters,null,0,false).init();